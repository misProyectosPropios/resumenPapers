## Introducción

Habla sobre que va a tratar el paper. Por qué es necesario entenderlo, la forma de entenderlo de Naur y experiencias.

## Programming and the Programmers’ Knowledge

Programación: toda la actividad de diseño e implementación de soluciones programadas
Esta connotación sirve para el desarrollo a lo largo del tiempo y las modificaciones añadidas al código. Además es la construcción de una cierta clase de conocimiento del programador, siendo este la posesión inmediata del programador y de forma secundaria la documentación.
+ Da el ejemplo del compilador: los que lo desarrollaron se lo dieron al grupo b que no lo conocía. Le querían agregar ciertas features al programa y no eran las mejores y no aprovechaban el compilador porque les faltaba el conocimento
+ Da ejemplo de un programa largo (200.000 lineas). Estas el grupo que lo diseño los puede resolver facilmente sin problemas, mientras que los que tenían que agregar cosas y no lo habían tocado antes el programa se les dificultaba.
**Conclusión**: Con programas largos, la adopción larga, modificación y correción de errores son dependientes de un cierto conocimiento que los tenían previamente los programadores

## Ryle’s Notion of Theory

Como caracterizamos ese conocimiento más detalladamente?
Usamos **Ryle's Theory**. Quien posee una teoría es capaz de hacer ciertas cosas, explicaciones y respuestas a consultas. Es una actividad intelectual, que va más allá de la no. La performance inteligente se mide en la medida que se hagan bien las cosas. Pero no hay una manera clara de medir que se hagan bien las cosas, al no haber una serie de reglas con las que constatar

## The Theory To Be Built by the Programmer

Los programadores tienen que crear una teoría sobre como ciertos aspectos de la vida real serán tratados o manejados por un programa. 
La teoría del programador es más importante que el texto, el programa y la documentación.

**Por qué?** Hay 3 áreas esenciales:
1) El programador con la teoría puede explicar la relación de la solución con la vida real que soluciona. En varias direcciones: como afecta a la realidad y la "mapeada" en el texto del programa y la documentación hecha. La decisión que una parte del mundo no es relevante es hecha según quien entiende que es relevante o no (el programador)
2) 