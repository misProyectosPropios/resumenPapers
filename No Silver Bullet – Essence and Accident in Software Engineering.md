
## Artículo

Link: https://worrydream.com/refs/Brooks_1986_-_No_Silver_Bullet.pdf

## Abstract

El desarrollo del software tiene tareas esenciales y tareas accidentales. Los desarrollos pasados solucionaron tareas accidentales. Como podemos aumentar la productividad? Tenemos que basarnos en la parte esencial.
## Introduction

Queremos una *Silver bullet* para evitar que los programas se vuelvan monstruos (usa la metáfora del hombre lobo) 

El primer paso es el reemplazo de la teoría por la inicial (*germ theory*)
## Does It Have To Be Hard? – Essential Difficulties

Es complicado ver que encontraremos una solución de mejora como la del hardware por esencia compleja del software. A diferencia del hardware.
La esencia es una construcción de *interlocking concepts*.  Lo difícil de construir software es la especificación, diseño y testeo. 
Si es cierto, siempre va a ser difícil construir software.

+ Complexity: 
    + they are most complex by their size because theres no 2 parts alike. 
        + If they are, we make the two similar parts into one, a subroutine, open or closed. 
    + Doesn't exists repeated elements abound unlike computers. 
    + Conceiving, describing, and testing them hard
    + Scaling-up of a software 
        + The complexity of the whole increases much more than linearly.
    + The complexity of things **are** the essence, we can't ignore it. We can't abstract away the complexity of it.
    + Enumerating -> less understanding -> all possible states of the program -> unreliability
    + Complex structure generates
        + extending programs to new functions without creating side effects.
        + unvisualized state of trapdoors
    + Managanagement problems
+ Conformity: 
    + arbitrary complexity, forced without rhyme or reason by the many human institutions and systems to which his interfaces must confirm
    + In others it must conform because it is perceived as the most conformable
+ Changeability: 
    + Constantly subject to pressures for change because 
        + software can be changed more easily and cheapear than a building for example
    + Software used:
        + -> tried beyond -> gets modifications
    + cultural matrix of applications, users, laws, and machine vehicles. These all change continually, and their changes inexorably force change upon the software product
+ Invisibility: 
    + invisible and unvisualizable
    + not inherently embedded in space.
        + no ready geometric representation in the way that land has maps
    + flow of control, the flow of data, patterns of dependency, time sequence, name-space relationship

## Past Breakthroughs Solved Accidental Difficulties
Las soluciones para las dificultades accidentales creadas hasta ahora son: 
+ High-level languages
    + It frees a program from much of its accidental complexity. 
    + Furnish all the constructs the programmer imagines in the abstract program.
+ Time-sharing:
    + preserves immediacy -> maintain an overview of complexity.
+ Unified programming environments:
    + using programs together, by providing integrated libraries, unified file formats, and piles and filters
    + development of whole toolbenches
## Hopes for the Silver

Los desarrollos técnicos que pueden llegar a ser silver bullets:
+ Ada an other high-level language advances: #TODO
+ Object oriented programming: #TODO
+ Artificial intelligence: #TODO
+ Expert systems: #TODO
+ "Automatic" programming: #TODO
+ Graphical programming: #TODO
+ Program verification: 
    + Doesn't believe it's the cure. does not promise, however, to save labor. Just that it'll work
    + does not mean error-proof programs. 
+ Environments and tools: #TODO
+ Workstations: #TODO

## Promising Attacks on the Conceptual Essence
Algunas posibles soluciones a la esencia de la programación:
+ Buy versus build:
    + not to construct it at all. Many vendors sell more and cheaper tools. Create them its more expensive. cheaper to buy than to build afresh
    + Cheaper computer -> people could not afford 50k for a program, so use what other do
+ Requirements refinement and rapid prototyping
    + deciding precisely what to build.
    + Imposible to define correctly the specifications
    + development of approaches and tools for rapid prototyping of systems as part of the iterative specification of requirements.
+ Incremental development-grow, not build, software
    + The building metaphor has outlived its usefulness. 
    + Metaphor of a brain. The secret is that it is grown, not built.
    + Enthusiasm jumps when there is a running system, even a simple one.
    + One has at every moment a working system
+ Great designers
    + Look how the people worked before
    + Great designs come from great designers.
    + Model faster, smaller, simpler, cleaner, and produced with less effort
    + develop ways to grow great designers
        + Reward great designers

    + Steps
        + identify top designers as early as possible. 
        + Assign a career mentor to be responsible for the development of the prospect
        + maintain a career development plan
        + Advanced formal education, and short course
        + opportunities for growing designers to interact with and stimulate each other.
